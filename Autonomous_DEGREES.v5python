{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nleftmg_motor_a = Motor(Ports.PORT1, GearSetting.RATIO_36_1, True)\nleftmg_motor_b = Motor(Ports.PORT9, GearSetting.RATIO_36_1, True)\nleftmg = MotorGroup(leftmg_motor_a, leftmg_motor_b)\nrightmg_motor_a = Motor(Ports.PORT13, GearSetting.RATIO_36_1, False)\nrightmg_motor_b = Motor(Ports.PORT20, GearSetting.RATIO_36_1, False)\nrightmg = MotorGroup(rightmg_motor_a, rightmg_motor_b)\ncontroller_1 = Controller(PRIMARY)\nScissorLift = Motor(Ports.PORT6, GearSetting.RATIO_18_1, False)\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\n\n# define variables used for controlling motors based on controller inputs\ncontroller_1_right_shoulder_control_motors_stopped = True\ncontroller_1_up_down_buttons_control_motors_stopped = True\ncontroller_1_x_b_buttons_control_motors_stopped = True\n\n# define a task that will handle monitoring inputs from controller_1\ndef rc_auto_loop_function_controller_1():\n    global controller_1_right_shoulder_control_motors_stopped, controller_1_up_down_buttons_control_motors_stopped, controller_1_x_b_buttons_control_motors_stopped, remote_control_code_enabled\n    # process the controller input every 20 milliseconds\n    # update the motors based on the input values\n    while True:\n        if remote_control_code_enabled:\n            # check the buttonR1/buttonR2 status\n            # to control ScissorLift\n            if controller_1.buttonR1.pressing():\n                ScissorLift.spin(FORWARD)\n                controller_1_right_shoulder_control_motors_stopped = False\n            elif controller_1.buttonR2.pressing():\n                ScissorLift.spin(REVERSE)\n                controller_1_right_shoulder_control_motors_stopped = False\n            elif not controller_1_right_shoulder_control_motors_stopped:\n                ScissorLift.stop()\n                # set the toggle so that we don't constantly tell the motor to stop when\n                # the buttons are released\n                controller_1_right_shoulder_control_motors_stopped = True\n            # check the buttonUp/buttonDown status\n            # to control leftmg\n            if controller_1.buttonUp.pressing():\n                leftmg.spin(FORWARD)\n                controller_1_up_down_buttons_control_motors_stopped = False\n            elif controller_1.buttonDown.pressing():\n                leftmg.spin(REVERSE)\n                controller_1_up_down_buttons_control_motors_stopped = False\n            elif not controller_1_up_down_buttons_control_motors_stopped:\n                leftmg.stop()\n                # set the toggle so that we don't constantly tell the motor to stop when\n                # the buttons are released\n                controller_1_up_down_buttons_control_motors_stopped = True\n            # check the buttonX/buttonB status\n            # to control rightmg\n            if controller_1.buttonX.pressing():\n                rightmg.spin(FORWARD)\n                controller_1_x_b_buttons_control_motors_stopped = False\n            elif controller_1.buttonB.pressing():\n                rightmg.spin(REVERSE)\n                controller_1_x_b_buttons_control_motors_stopped = False\n            elif not controller_1_x_b_buttons_control_motors_stopped:\n                rightmg.stop()\n                # set the toggle so that we don't constantly tell the motor to stop when\n                # the buttons are released\n                controller_1_x_b_buttons_control_motors_stopped = True\n        # wait before repeating the process\n        wait(20, MSEC)\n\n# define variable for remote controller enable/disable\nremote_control_code_enabled = True\n\nrc_auto_loop_thread_controller_1 = Thread(rc_auto_loop_function_controller_1)\n#endregion VEXcode Generated Robot Configuration\n\nvexcode_brain_precision = 0\nvexcode_console_precision = 0\nvexcode_controller_1_precision = 0\nLeftVelo = 0\nRightVelo = 0\nprintPeriodic = 0\nwheelCircumference = 12.566\nwheelDiameter = 4\ngearRatio = 1\nautonDrivePCT = 50\nleftMotorDegreesPerInch = 10.475\nrightMotorDegreesPerInch = 10.475\nspeedChangePerLoop = 0.06\nleftCurrentPosi = 1\nrightCurrentPosi = 1\ntargetLeft = 100\ntargetRight = 100\n\n\n# def accelerateForward(rightDirection, leftDirection,rightVelocity,leftvelocity):\n#     while(leftCurrentPosi<targetLeft or rightCurrentPosi<targetRight):\n#         rightmg.position(DEGREES)\n#         leftmg.position(DEGREES)\n#         rightVelo = accelerate(rightCurrentPosi)\n#         leftVelo = accelerate(leftCurrentPosi)\n#         rightmg.set_velocity(rightVelo,PERCENT)\n#         leftmg.set_velocity(leftVelo,PERCENT)\n#         rightmg.position(DEGREES)\n#         leftmg.position(DEGREES)\n#         wait(100,MSEC)\n\ndef testMove(direction, degrees, rightVelocity, leftVelocity, caliberation):\n    print(\"test Move has started\")\n    #get current position\n    leftCurrentPosi = leftmg.position(DEGREES)\n    rightCurrentPosi = rightmg.position(DEGREES)   \n    rightmg.set_velocity(rightVelocity, PERCENT)\n    leftmg.set_velocity(leftVelocity,PERCENT)    \n    leftMotorDegrees = degrees + leftCurrentPosi\n    rightMotorDegrees = degrees + rightCurrentPosi\n    \n    print(\"Right Motor Degrees:\" + str(rightMotorDegrees) + \" left motor degrees: \" + str(leftMotorDegrees)) \n    rightmg.spin_for(direction,rightMotorDegrees, DEGREES, wait=False)\n    leftmg.spin_for(direction,leftMotorDegrees, DEGREES, wait=False)  \n    while (abs(leftCurrentPosi) < leftMotorDegrees and abs(rightCurrentPosi) < rightMotorDegrees and rightmg.is_spinning() and leftmg.is_spinning()):\n        leftCurrentPosi = leftmg.position(DEGREES)\n        rightCurrentPosi = rightmg.position(DEGREES)\n        if abs(leftCurrentPosi) < abs(rightCurrentPosi):\n            rightmg.set_velocity(rightVelocity - caliberation, PERCENT)\n            leftmg.set_velocity(leftVelocity + caliberation,PERCENT)\n        elif abs(rightCurrentPosi) > abs(leftCurrentPosi):\n            rightmg.set_velocity(rightVelocity + caliberation, PERCENT)\n            leftmg.set_velocity(leftVelocity - caliberation,PERCENT)\n        else: \n            rightmg.set_velocity(rightVelocity, PERCENT)\n            leftmg.set_velocity(leftVelocity,PERCENT)\n        print(\"waiting Left Position:\"+ str(leftmg.position(DEGREES)) + \" Right Position:\" + str(rightmg.position(DEGREES)))\n        wait(1, MSEC)    \n    print(\"testMove is completed\")    \n\ndef moveStraight(direction, distance, rightVelocity, leftVelocity, caliberation):\n    print(\"moving straight\")\n    #get current position\n    leftCurrentPosi = leftmg.position(DEGREES)\n    rightCurrentPosi = rightmg.position(DEGREES)\n    #set target velocity\n    #TODO: steady acceleration\n    rightmg.set_velocity(rightVelocity, PERCENT)\n    leftmg.set_velocity(leftVelocity,PERCENT)\n    #calculate the target degrees\n    leftMotorDegrees = leftMotorDegreesPerInch * distance\n    rightMotorDegrees = rightMotorDegreesPerInch * distance\n    print(\"Left Motor Degrees:\" + str(leftMotorDegrees)) \n    print(\"Right Motor Degrees:\" + str(rightMotorDegrees))\n    #start moving    \n    print(\"Left Motor Degrees:\" + str(leftMotorDegrees)) \n    print(\"Right Motor Degrees:\" + str(rightMotorDegrees))\n    rightmg.spin_for(direction,rightMotorDegrees + rightCurrentPosi, DEGREES, wait=False)\n    leftmg.spin_for(direction,leftMotorDegrees + leftCurrentPosi, DEGREES, wait=False)\n    while leftCurrentPosi < leftMotorDegrees:\n        leftCurrentPosi = leftmg.position(DEGREES)\n        rightCurrentPosi = rightmg.position(DEGREES)\n        if leftCurrentPosi < rightCurrentPosi:\n            rightmg.set_velocity(rightVelocity - caliberation, PERCENT)\n            leftmg.set_velocity(leftVelocity + caliberation,PERCENT)\n        elif rightCurrentPosi > leftCurrentPosi:\n            rightmg.set_velocity(rightVelocity + caliberation, PERCENT)\n            leftmg.set_velocity(leftVelocity - caliberation,PERCENT)\n        else: \n            rightmg.set_velocity(rightVelocity, PERCENT)\n            leftmg.set_velocity(leftVelocity,PERCENT)\n        wait(5, MSEC)\n    print(\"moved straight\")\n\t\ndef moveDistance(direction ,distance,rightVelocity, leftVelocity):\n    print(\"Starting move distance\")\n    leftCurrentPos = leftmg.position(DEGREES)\n    rightCurrentPos = rightmg.position(DEGREES)\n    rightmg.set_velocity(rightVelocity,PERCENT)\n    leftmg.set_velocity(leftVelocity,PERCENT)\n    leftMotorDegrees = leftMotorDegreesPerInch * distance\n    rightMotorDegrees = rightMotorDegreesPerInch * distance\n    print(\"Left Motor Degrees:\" + str(leftMotorDegrees)) \n    print(\"Right Motor Degrees:\" + str(rightMotorDegrees))\n    rightmg.spin_for(direction,rightMotorDegrees + rightCurrentPos, DEGREES, wait=False)\n    leftmg.spin_for(direction,leftMotorDegrees + leftCurrentPos, DEGREES, wait=False)\n    print(\"Move distance complete\")\n    \ndef move_position(rightDirection, leftDirection, rightVelocity, leftVelocity, rightPosi, leftPosi):\n    print(\"Starting Move Posistion\", rightPosi, leftPosi)\n    leftCurrentPos = leftmg.position(DEGREES)\n    rightCurrentPos = rightmg.position(DEGREES)\n    print(\"Left Current Posi:\"+ str(leftCurrentPos))\n    print(\"Right Current Posi:\"+ str(rightCurrentPos))\n    rightmg.set_velocity(rightVelocity,PERCENT)\n    leftmg.set_velocity(leftVelocity,PERCENT)\n    #rightmg.spin(FORWARD)\n    #leftmg.spin(FORWARD)\n    rightmg.spin_for(rightDirection, rightPosi + rightCurrentPos, DEGREES, wait=False)\n    leftmg.spin_for(leftDirection, leftPosi + leftCurrentPos, DEGREES, wait=False)\n    #rightmg.spin_to_position(rightPosi + rightCurrentPos, DEGREES, wait=False)\n    #leftmg.spin_to_position(leftPosi + leftCurrentPos, DEGREES, wait=False)\n   \n    #rightmg.stop()\n    #leftmg.stop()\n    print(\"Move position completed\")\n\ndef turn(direction,degrees,velocity,waitSeconds):    \n    # main thread\n    # Turn both motors on\n    print(\"Turn is starting\")\n    if direction == \"right\":\n        rightmg.spin_to_position(degrees, DEGREES, wait=True)\n        #rightmg.set_position(degrees, DEGREES)\n        rightmg.set_velocity(velocity,PERCENT)\n        rightmg.spin(FORWARD)\n        print(str(degrees) + \" is how degrees turned \")\n    else:\n        leftmg.spin_to_position(degrees, DEGREES, wait=True)\n        #leftmg.set_position(degrees, DEGREES)\n        leftmg.set_velocity(velocity,PERCENT)\n        leftmg.spin(FORWARD)\n        print(str(degrees) + \" is how degrees turned \")\n    \n    wait(waitSeconds,SECONDS)\n    print(\"Turn is completed\")\n\ndef lift(velocity,waitSeconds):\n    print(\"Lifting\")\n    ScissorLift.set_velocity(velocity,PERCENT)\n    ScissorLift.spin(FORWARD)\n    wait(waitSeconds,SECONDS)\n    ScissorLift.stop()\n    print(\"Lift is completed\")\n\ndef print_state():\n    disp = {\"LeftMotorDone\":leftmg.is_done(),\"RightMotorDone\":rightmg.is_done()\n    ,\"LeftMotorSpinning\":leftmg.is_spinning(),\"RightMotorSpinning\":rightmg.is_spinning()}\n    for key, value in disp.items():\n        print(key + ':' + str(value))\n        brain.screen.print(key + ':' + str(value) , precision=6 if vexcode_brain_precision is None else vexcode_brain_precision)\n        brain.screen.next_row()\n\n# resets motor degrees  \ndef reset_state():\n    print(\"Reseting motors\")\n    rightmg.set_position(0,TURNS)\n    leftmg.set_position(0,DEGREES)\n    rightmg.set_velocity(0,PERCENT)\n    leftmg.set_velocity(0,PERCENT)\n    print(\"Finished reseting motors\")\n    #auto_wait()\n\ndef stop_motors():\n    print(\"Motors stopping\")\n    rightmg.stop()\n    leftmg.stop()\n    print(\"Motors have stopped\")\n\ndef auto_wait():\n    print(\"auto wait has started\")\n    leftmg_running = True \n    rightmg_running = True\n    while leftmg_running == True or rightmg_running == True:\n        rightmg_running = rightmg.is_spinning()\n        leftmg_running = leftmg.is_spinning()\n        print(\"waiting Left Position:\"+ str(leftmg.position(DEGREES)) + \" Right Position:\" + str(rightmg.position(DEGREES)))\n        wait(5, MSEC)\n    print(\"stopped Left Position:\"+ str(leftmg.position(DEGREES)) + \" Right Posistion:\" + str(rightmg.position(DEGREES)))  \n    print(\"auto_wait is finished\")\n\n\ndef bottom_right_position():\n    reset_state()\n    #current_right_posi = rightmg.position(DEGREES)\n    #current_left_posi = leftmg.position(DEGREES)\n    move_position(FORWARD,FORWARD,40, 40, 756, 756)\n    #wait(5,SECONDS)\n    auto_wait()\n    reset_state()\n    move_position(FORWARD,REVERSE,20, -20, 144, 180)\n    #wait(5,SECONDS)\n    auto_wait()\n    reset_state()\n    move_position(FORWARD,FORWARD,40, 40, 756, 756)\n    #wait(5,SECONDS)\n    auto_wait()\n    reset_state()\n    move_position(REVERSE,REVERSE,-40, -40, 756, 756)\n    #wait(5,SECONDS)\n    auto_wait()\n    reset_state()\n    move_position(REVERSE,FORWARD,-20, 20, 144, 180)\n    #wait(5,SECONDS)\n    auto_wait()\n    reset_state()\n    move_position(REVERSE,REVERSE,-40, -40, 756, 756)\n    #stop()\ndef moveByDistance():\n    stop_motors()\n    reset_state()\n    print(\"Moving Forward by 4 ft\")\n    moveDistance(FORWARD,46, 25, 25)\n    auto_wait()\n    print(\"Moved Forward by 4 ft\")\n    reset_state()\n    moveDistance(REVERSE,46,-25,-25)\n    auto_wait()\ndef acceleration():\n    stop_motors()\n    #reset_state()  \n    #moveStraight(FORWARD, 48, 50, 50, 5)\n    print('******moving forward1')\n    print(\"Right Motor posi:\" + str(rightmg.position(DEGREES)) + \" left motor posi: \" + str(rightmg.position(DEGREES)))   \n    testMove(FORWARD, 360*2, 30,30,5)\n    auto_wait()\n    reset_state()\n    wait(2,SECONDS)\n    print('******moving forward2')\n    print(\"Right Motor posi:\" + str(rightmg.position(DEGREES)) + \" left motor posi: \" + str(rightmg.position(DEGREES)))      \n    testMove(FORWARD, 360*2, 30,30,5)\n    auto_wait()\n    reset_state()\n    wait(2,SECONDS)    \n    #reset_state()\n    #moveStraight(REVERSE, 48, -50, -50, -5)\n    print('******moving reverse1')\n    print(\"Right Motor posi:\" + str(rightmg.position(DEGREES)) + \" left motor posi: \" + str(rightmg.position(DEGREES)))      \n    testMove(REVERSE, 360*2, 30,30,5)\n    auto_wait()\n    reset_state()\n    wait(2,SECONDS)\n    print('******moving reverse2')\n    print(\"Right Motor posi:\" + str(rightmg.position(DEGREES)) + \" left motor posi: \" + str(rightmg.position(DEGREES)))      \n    testMove(REVERSE, 360*2,30, 30,5)\n    auto_wait()\n    reset_state()\n    wait(2,SECONDS)    \n\n    #auto_wait()\n    stop_motors()\n    #moveStraight(TURN, distance, rightVelocity, leftVelocity)\n# def acceleration():\n#     stop_motors()\n#     reset_state()\n#     accelerateForward(FORWARD, FORWARD,50,50)\n#     reset_state()\n#     auto_wait()\n#     accelerateForward(FORWARD,REVERSE,25,-25)\n#     reset_state()\n#     auto_wait()\n#     accelerateForward(FORWARD,FORWARD,50,50)\n\ndef when_started1():\n    global LeftVelo, printPeriodic, RightVelo, vexcode_brain_precision, vexcode_console_precision, vexcode_controller_1_precision \n    #controller_1.buttonA.pressed(bottom_right_position)\n    #controller_1.buttonA.pressed(moveByDistance)\n    controller_1.buttonA.pressed(acceleration)\n    \n    \nwhen_started1()   \n    \n\n \n","textLanguage":"python","rconfig":[{"port":[1,9],"name":"leftmg","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","gear":"ratio36_1","motor_a_reversed":"true","motor_b_reversed":"true"},"triportSourcePort":22},{"port":[13,20],"name":"rightmg","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","gear":"ratio36_1","motor_a_reversed":"false","motor_b_reversed":"false"},"triportSourcePort":22},{"port":[],"name":"controller_1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"ScissorLift","rightDir":"false","upDown":"leftmg","upDownDir":"false","xB":"rightmg","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22},{"port":[6],"name":"ScissorLift","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22}],"slot":0,"platform":"V5","sdkVersion":"20211013.15.00.00","appVersion":"2.2.1","fileFormat":"1.0.1","icon":"","targetBrainGen":"First","target":"Physical"}